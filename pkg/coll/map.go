package coll

import (
	"strings"
)

// ContainsKeyComp checks if a specified key is present within a given map.
//
// This function takes a map with keys of any comparable type `K` and values of
// any type `V`. It checks if the specified `key` exists in the map `m`. If the key
// is found, it returns `true`; otherwise, it returns `false`.
//
// The function is generic and can be used with maps that have keys of any type
// that supports comparison (e.g., int, string). The value type `V` can be any type.
//
// Parameters:
//   - `m`: The map in which to search for the key. The map has keys of type `K`
//     and values of type `V`.
//   - `key`: The key to search for within `m`. It should be of the same type `K` as
//     the keys in `m`.
//
// Returns:
//   - `true` if `key` is found in `m`, `false` otherwise.
//
// Example:
//
//	ages := map[string]int{"Alice": 30, "Bob": 25}
//	isPresent := ContainsKeyComp(ages, "Alice") // isPresent will be true as "Alice" is a key in the map
//
//	prices := map[int]float64{1: 9.99, 2: 19.99}
//	isPresent := ContainsKeyComp(prices, 3) // isPresent will be false as 3 is not a key in the map
func ContainsKeyComp[K comparable, V any](m map[K]V, key K) bool {
	_, ok := m[key]
	return ok
}

// Map returns a new slice where each element is the result of applying a specified
// transformation function to each element in the input slice.
//
// This function iterates over each element in the input slice `list`, applies the
// provided transformation function `f` to it, and stores the result in the new slice
// `result`. The length of the resulting slice is the same as the input slice, and
// each element in `result` corresponds to a transformed element from `list`.
//
// The function is generic, allowing it to work with slices of any type `T` and
// apply a transformation function that converts each element of type `T` to a
// new type `U`.
//
// Parameters:
//   - `list`: The slice of elements to transform. It can contain elements of any type `T`.
//   - `f`: A function that defines the transformation. It takes an element of type `T`
//     as input and returns a transformed value of type `U`.
//
// Returns:
//   - A new slice of type `[]U` where each element is the result of applying `f`
//     to the corresponding element in `list`.
//
// Example:
//
//	numbers := []int{1, 2, 3, 4, 5}
//	squaredNumbers := Map(numbers, func(n int) int { return n * n })
//	// squaredNumbers will be []int{1, 4, 9, 16, 25} as each number is squared
//
//	words := []string{"apple", "banana", "cherry"}
//	wordLengths := Map(words, func(word string) int { return len(word) })
//	// wordLengths will be []int{5, 6, 6} as each word's length is calculated
func Map[T any, U any](list []T, f func(T) U) []U {
	result := make([]U, len(list))
	for i, item := range list {
		result[i] = f(item)
	}
	return result
}

// ToMap converts a slice into a map, using a specified function to generate keys
// for each element in the slice.
//
// This function iterates over each element in the input slice `slice`, applies the
// provided `keyFunc` function to generate a key for each element, and then inserts the
// element into the resulting map `result` using that key. This allows the creation of
// a map from a slice, where each element is accessible via a unique key.
//
// The function is generic, allowing it to operate on slices of any type `T` and
// generate keys of any comparable type `K`. The resulting map will have keys of
// type `K` and values of type `T`.
//
// Parameters:
//   - `slice`: The slice of elements to convert to a map. It can contain elements of any type `T`.
//   - `keyFunc`: A function that takes an element of type `T` and returns a key of type `K`,
//     which is used as the key for each element in the resulting map.
//
// Returns:
//   - A map of type `map[K]T`, where each element in `slice` is inserted using the key
//     generated by `keyFunc`. If `keyFunc` generates the same key for multiple elements,
//     the last one will overwrite the previous entry in the map.
//
// Example:
//
//	// Converting a slice of strings to a map with string lengths as keys
//	words := []string{"apple", "banana", "cherry"}
//	wordMap := ToMap(words, func(word string) int { return len(word) })
//	// wordMap will be map[int]string{5: "apple", 6: "cherry"}
//	// Note: "banana" is overwritten by "cherry" as they have the same key 6
//
//	// Converting a slice of structs to a map using a struct field as the key
//	type Person struct {
//	    ID   int
//	    Name string
//	}
//	people := []Person{{ID: 1, Name: "Alice"}, {ID: 2, Name: "Bob"}}
//	personMap := ToMap(people, func(p Person) int { return p.ID })
//	// personMap will be map[int]Person{1: {ID: 1, Name: "Alice"}, 2: {ID: 2, Name: "Bob"}}
func ToMap[T any, K comparable](slice []T, keyFunc func(T) K) map[K]T {
	result := make(map[K]T)
	for _, item := range slice {
		result[keyFunc(item)] = item
	}
	return result
}

// ToSlice applies a mapping function to each element in the input slice
// and returns a new slice containing the results of the mapping.
//
// This function iterates over each element in the input slice `slice` and applies
// the provided `mapper` function to each element. The result of applying the mapping
// function to each element is stored in a new slice `mappedSlice`. This allows for
// transforming the elements of the input slice into a new slice of a different type.
//
// The function is generic, allowing it to work with slices of any type `T` as input,
// and the result can be a slice of any type `U`.
//
// Parameters:
//   - `slice`: The input slice containing elements of type `T` to be mapped.
//   - `mapper`: A function that takes an element of type `T` and returns a transformed
//     element of type `U`.
//
// Returns:
//   - A new slice of type `[]U` containing the mapped elements, with the same length
//     as the input slice, but with elements transformed according to the `mapper` function.
//
// Example:
//
//	// Mapping a slice of integers to their string representations
//	numbers := []int{1, 2, 3}
//	mappedStrings := ToSlice(numbers, func(n int) string {
//		return fmt.Sprintf("Number %d", n)
//	})
//	// mappedStrings will be []string{"Number 1", "Number 2", "Number 3"}
//
//	// Mapping a slice of strings to their lengths
//	words := []string{"apple", "banana", "cherry"}
//	mappedLengths := ToSlice(words, func(word string) int {
//		return len(word)
//	})
//	// mappedLengths will be []int{5, 6, 6}
//
//	// Mapping an empty slice returns an empty slice
//	empty := []int{}
//	mappedEmpty := ToSlice(empty, func(n int) string {
//		return fmt.Sprintf("Number %d", n)
//	})
//	// mappedEmpty will be []string{}
func ToSlice[T any, U any](slice []T, mapper func(T) U) []U {
	mappedSlice := make([]U, len(slice))
	for i, item := range slice {
		mappedSlice[i] = mapper(item)
	}
	return mappedSlice
}

// Merge combines multiple maps into a single map. If there are any key conflicts,
// the value from the last map will be used.
//
// This function accepts a variable number of maps of type `map[interface{}]V` and merges
// them into a single map. It iterates through each input map, adding all key-value pairs
// to the `mergedMap`. If a key already exists in `mergedMap`, the corresponding value
// from the current map will overwrite the existing value. The function returns the merged map.
//
// The function is generic, allowing it to work with maps where the key is of any type `K`
// and the value is of any type `V`. It uses `interface{}` as the key type, enabling it to
// handle a variety of key types, though this may require careful handling of the key types
// to ensure they are comparable if needed.
//
// Parameters:
//   - `maps`: A variadic parameter representing multiple maps to be merged. Each map has keys
//     of type `interface{}` and values of type `V`.
//
// Returns:
//   - A new map of type `map[interface{}]V` containing the merged key-value pairs. If there
//     are key conflicts, the last map's value will be used.
//
// Example:
//
//	// Merging two maps with integer keys and string values
//	map1 := map[interface{}]string{"a": "apple", "b": "banana"}
//	map2 := map[interface{}]string{"b": "blueberry", "c": "cherry"}
//	merged := Merge(map1, map2)
//	// merged will be map[interface{}]string{"a": "apple", "b": "blueberry", "c": "cherry"}
//
//	// Merging maps with different value types (e.g., int and string)
//	map3 := map[interface{}]int{"x": 10, "y": 20}
//	map4 := map[interface{}]string{"y": "yellow", "z": "zebra"}
//	mergedMixed := Merge(map3, map4)
//	// mergedMixed will be map[interface{}]string{"x": "10", "y": "yellow", "z": "zebra"}
//
//	// Merging an empty slice of maps returns an empty map
//	mergedEmpty := Merge()
//	// mergedEmpty will be an empty map
func Merge[K any, V any](maps ...map[any]V) map[any]V {
	merged := make(map[any]V)
	for _, m := range maps {
		for k, v := range m {
			merged[k] = v
		}
	}
	return merged
}

// DeepMerge merges two maps, deeply combining values from the source map into the target map.
//
// This function takes two maps: `target` and `source`, both with string keys and interface{} values. It recursively merges
// the values from the `source` map into the `target` map. If a key exists in both maps, the function checks if the values
// associated with the key are themselves maps. If so, it recursively merges the nested maps. Otherwise, it directly overwrites
// the target map's value with the value from the source map. This function allows for deep merging of nested maps.
//
// The function modifies the `target` map in place and does not return anything.
//
// Parameters:
//   - `target`: The map that will be updated with values from the `source`. It is modified in place.
//   - `source`: The map whose values will be merged into the `target`.
//
// Example:
//
//	// Merging two maps with nested maps
//	target := map[string]interface{}{
//		"fruit": map[string]interface{}{"apple": 5, "banana": 10},
//		"vegetable": map[string]interface{}{"carrot": 3},
//	}
//	source := map[string]interface{}{
//		"fruit": map[string]interface{}{"banana": 7, "orange": 2},
//		"vegetable": map[string]interface{}{"spinach": 5},
//		"grain": 100,
//	}
//	DeepMerge(target, source)
//	// target will now be:
//	// map[string]interface{}{
//	//		"fruit": map[string]interface{}{"apple": 5, "banana": 7, "orange": 2},
//	//		"vegetable": map[string]interface{}{"carrot": 3, "spinach": 5},
//	//		"grain": 100,
//	//	}
//
//	// If there is no conflict, the value from the source is added as is.
//	// If the source value is a nested map, the function will perform a deep merge.
func DeepMerge(dst, src map[string]any) map[string]any {
	// for key, sourceValue := range source {
	// 	if targetValue, exists := target[key]; exists {
	// 		if sourceMap, sourceIsMap := sourceValue.(map[string]any); sourceIsMap {
	// 			if targetMap, targetIsMap := targetValue.(map[string]any); targetIsMap {
	// 				DeepMerge(targetMap, sourceMap)
	// 			}
	// 		} else {
	// 			target[key] = sourceValue
	// 		}
	// 	} else {
	// 		target[key] = sourceValue
	// 	}
	// }

	result := make(map[string]any, len(dst))

	// Copy dst
	for k, v := range dst {
		result[k] = v
	}

	// Merge src
	for k, v := range src {
		if dstVal, ok := result[k]; ok {
			// If both are maps, merge recursively
			if dstMap, isDstMap := dstVal.(map[string]any); isDstMap {
				if srcMap, isSrcMap := v.(map[string]any); isSrcMap {
					result[k] = DeepMerge(dstMap, srcMap)
					continue
				}
			}
		}
		result[k] = v
	}

	return result
}

// FilterMap filters the key-value pairs of a map based on a condition provided by the filter function.
//
// This function iterates over each key-value pair in the input map `m` and applies the provided
// `filter` function to the value. If the `filter` function returns `true` for a value, that key-value
// pair is added to the `filteredMap`. Otherwise, the pair is excluded. The function returns a new map
// containing only the key-value pairs that satisfy the condition specified in the `filter` function.
//
// The function is generic, allowing it to work with maps where the keys and values can be of any type `K`
// and `V`, respectively.
//
// Parameters:
//   - `m`: The input map to be filtered, with keys of type `any` and values of type `V`.
//   - `filter`: A function that takes a value of type `V` and returns a boolean. It determines
//     whether the corresponding key-value pair should be included in the result map.
//
// Returns:
//   - A new map of type `map[any]V`, containing only the key-value pairs for which the `filter`
//     function returned `true`.
//
// Example:
//
//	// Filtering a map of integers, keeping only values greater than 10
//	map1 := map[any]int{"a": 5, "b": 15, "c": 20}
//	filtered := FilterMap(map1, func(v int) bool {
//		return v > 10
//	})
//	// filtered will be map[any]int{"b": 15, "c": 20}
//
//	// Filtering a map of strings, keeping only values with length greater than 3
//	map2 := map[any]string{"a": "apple", "b": "banana", "c": "cat"}
//	filteredStrings := FilterMap(map2, func(v string) bool {
//		return len(v) > 3
//	})
//	// filteredStrings will be map[any]string{"a": "apple", "b": "banana"}
//
//	// Filtering an empty map returns an empty map
//	emptyMap := map[any]int{}
//	filteredEmpty := FilterMap(emptyMap, func(v int) bool {
//		return v > 10
//	})
//	// filteredEmpty will be an empty map
func FilterMap[K any, V any](m map[any]V, filter func(V) bool) map[any]V {
	filteredMap := make(map[any]V)
	for k, v := range m {
		if filter(v) {
			filteredMap[k] = v
		}
	}
	return filteredMap
}

// Values extracts and returns the values from a map as a slice.
//
// This function takes a map `m` with keys of type `any` and values of type `V`, and creates
// a new slice containing all the values from the map. The function iterates over the map and
// appends each value to the `values` slice. The resulting slice will have the same number of
// elements as the map has key-value pairs, and the order of values will correspond to the
// order in which they were iterated over (which is not guaranteed to be in any particular order).
//
// The function is generic, allowing it to work with maps of any key type `K` and value type `V`.
//
// Parameters:
//   - `m`: The input map from which to extract the values. The keys are of type `any`
//     and the values are of type `V`.
//
// Returns:
//   - A slice of type `[]V` containing all the values from the map `m`.
//
// Example:
//
//	// Extracting values from a map of strings to integers
//	map1 := map[any]int{"a": 1, "b": 2, "c": 3}
//	values := Values(map1)
//	// values will be []int{1, 2, 3}
//
//	// Extracting values from a map of strings to strings
//	map2 := map[any]string{"x": "apple", "y": "banana", "z": "cherry"}
//	valuesStrings := Values(map2)
//	// valuesStrings will be []string{"apple", "banana", "cherry"}
//
//	// Extracting values from an empty map returns an empty slice
//	emptyMap := map[any]int{}
//	emptyValues := Values(emptyMap)
//	// emptyValues will be []int{}
func Values[K any, V any](m map[any]V) []V {
	values := make([]V, len(m))
	i := 0
	for _, v := range m {
		values[i] = v
		i++
	}
	return values
}

// ValuesComp applies a transformation function to each value in a map
// and returns a new map with the same keys and transformed values.
//
// This function iterates over each key-value pair in the input map `m`, applies the
// provided transformation function `fn` to each value, and stores the result in a new map
// `result`. The keys in the resulting map remain the same as in the input map,
// while the values are transformed according to the function `fn`.
//
// The function is generic, allowing it to work with maps where the keys are of any
// comparable type `K`, the original values are of type `V`, and the transformed values
// are of type `U`.
//
// Parameters:
//   - `m`: The input map with keys of type `K` and values of type `V`.
//   - `fn`: A function that takes a value of type `V` and returns a transformed value of type `U`.
//
// Returns:
//   - A new map of type `map[K]U`, where each value is the result of applying `fn` to the
//     corresponding value in the input map `m`.
//
// Example:
//
//	// Transforming a map of integers to their string representations
//	m := map[string]int{"one": 1, "two": 2, "three": 3}
//	transformed := ValuesComp(m, func(v int) string {
//		return fmt.Sprintf("Number %d", v)
//	})
//	// transformed will be map[string]string{"one": "Number 1", "two": "Number 2", "three": "Number 3"}
func ValuesComp[K comparable, V, U any](m map[K]V, fn func(V) U) map[K]U {
	result := make(map[K]U, len(m))
	for k, v := range m {
		result[k] = fn(v)
	}
	return result
}

// JoinKeySep concatenates the keys of a map into a single string, with each key separated by a specified separator.
//
// This function takes a map `m` with string keys and any type of values `V`, and a `separator` string.
// It collects all the keys of the map into a slice, then joins them into a single string using the provided separator.
//
// This function is generic, allowing it to work with maps that have values of any type `V`.
//
// Parameters:
//   - `m`: A map with string keys and values of any type `V`. Only the keys are used for concatenation.
//   - `separator`: A string used to separate each key in the resulting string.
//
// Returns:
//   - A string containing all the keys in the map `m`, separated by the specified `separator`. If the map has no keys,
//     an empty string is returned.
//
// Example:
//
//	// Concatenating the keys of a map with a comma separator
//	m := map[string]int{"apple": 1, "banana": 2, "cherry": 3}
//	joinedKeys := JoinKeySep(m, ", ")
//	// joinedKeys will be "apple, banana, cherry"
//
//	// Using a different separator
//	m = map[string]bool{"cat": true, "dog": true}
//	joinedKeys = JoinKeySep(m, " | ")
//	// joinedKeys will be "cat | dog"
//
//	// With an empty map
//	emptyMap := map[string]int{}
//	joinedKeys = JoinKeySep(emptyMap, ",")
//	// joinedKeys will be ""
func JoinKeySep[V any](m map[string]V, separator string) string {
	joined_keys := []string{}
	for key := range m {
		joined_keys = append(joined_keys, key)
	}
	return strings.Join(joined_keys, separator)
}

// KeyComp returns all keys of a map.
//
// This function takes a map `m` with keys of type `K` and values of type `V`, and
// creates a new slice containing all the keys from the map. The function iterates
// over the map and appends each key to the `keys` slice. The resulting slice will have
// the same number of elements as the map has key-value pairs, and the order of keys
// will correspond to the order in which they were iterated over (which is not guaranteed
// to be in any particular order).
//
// The function is generic, allowing it to work with maps of any key type `K` and value type `V`.
//
// Parameters:
//   - `m`: The input map from which to extract the keys. The keys are of type `K`
//
// Returns:
//   - A slice of type `[]K` containing all the keys from the map `m`.
//
// Example:
//
//	// Extracting keys from a map of strings to integers
//	map1 := map[string]int{"a": 1, "b": 2, "c": 3}
//	keys := KeyComp(map1)
//	// keys will be []string{"a", "b", "c"}
func KeyComp[K comparable, V any](m map[K]V) []K {
	keys := make([]K, 0, len(m))
	for k := range m {
		keys = append(keys, k)
	}
	return keys
}

// MergeComp merges multiple maps into a new map.
// Later maps override earlier ones for duplicate keys.
//
// This function takes a variable number of maps with keys of type `K` and values of type `V`,
// and merges them into a single resulting map. It iterates through each input map,
// adding all key-value pairs to the `result` map. If a key already exists in `result`,
// the corresponding value from the current map will overwrite the existing value.
//
// The function is generic, allowing it to work with maps where the keys are of any
// comparable type `K` and the values are of any type `V`.
//
// Parameters:
//   - `maps`: A variadic parameter representing multiple maps to be merged. Each map has keys
//     of type `K` and values of type `V`.
//
// Returns:
//
//   - A new map of type `map[K]V` containing the merged key-value pairs. If there are
//
//     key conflicts, the last map's value will be used.
//
// Example:
//
//	// Merging two maps with string keys and integer values
//	map1 := map[string]int{"a": 1, "b": 2}
//	map2 := map[string]int{"b": 3, "c": 4}
//	merged := MergeComp(map1, map2)
//	// merged will be map[string]int{"a": 1, "b": 3, "c": 4}
func MergeComp[K comparable, V any](maps ...map[K]V) map[K]V {
	result := make(map[K]V)
	for _, m := range maps {
		for k, v := range m {
			result[k] = v
		}
	}
	return result
}

// PickComp creates a new map by selecting specific keys from the input map.
//
// This function takes an input map `m` with keys of type `K` and values of type `V`,
// along with a variadic list of keys to select. It iterates over the provided keys
// and checks if each key exists in the input map. If a key is found, it adds the corresponding
// key-value pair to the `result` map. The function returns a new map containing only
// the selected key-value pairs.
//
// The function is generic, allowing it to work with maps where the keys are of any
// comparable type `K` and the values are of any type `V`.
//
// Parameters:
//   - `m`: The input map from which to select key-value pairs. It has keys of type `K` and values of type `V`.
//   - `keys`: A variadic parameter representing the keys to select from the input map.
//
// Returns:
//   - A new map of type `map[K]V` containing only the key-value pairs for the specified keys.
//
// Example:
//
//	// Selecting specific keys from a map with string keys and integer values
//	m := map[string]int{"a": 1, "b": 2, "c": 3, "d": 4}
//	selected := PickComp(m, "b", "d")
//	// selected will be map[string]int{"b": 2, "d": 4}
func PickComp[K comparable, V any](m map[K]V, keys ...K) map[K]V {
	result := make(map[K]V, len(keys))
	for _, k := range keys {
		if v, ok := m[k]; ok {
			result[k] = v
		}
	}
	return result
}

// OmitComp creates a new map by excluding specific keys from the input map.
//
// This function takes an input map `m` with keys of type `K` and values of type `V`,
// along with a variadic list of keys to exclude. It first constructs a set of keys
// to omit, then iterates over the input map and adds key-value pairs to the `result` map
// only if the key is not in the omit set. The function returns a new map containing
// only the key-value pairs that are not excluded.
//
// The function is generic, allowing it to work with maps where the keys are of any
// comparable type `K` and the values are of any type `V`.
//
// Parameters:
//   - `m`: The input map from which to exclude key-value pairs. It has keys of type `K` and values of type `V`.
//   - `keys`: A variadic parameter representing the keys to exclude from the input map.
//
// Returns:
//   - A new map of type `map[K]V` containing only the key-value pairs that are not excluded.
//
// Example:
//
//	// Excluding specific keys from a map with string keys and integer values
//	m := map[string]int{"a": 1, "b": 2, "c": 3, "d": 4}
//	omitted := OmitComp(m, "b", "d")
//	// omitted will be map[string]int{"a": 1, "c": 3}
func OmitComp[K comparable, V any](m map[K]V, keys ...K) map[K]V {
	keySet := make(map[K]struct{}, len(keys))
	for _, k := range keys {
		keySet[k] = struct{}{}
	}

	result := make(map[K]V, len(m))
	for k, v := range m {
		if _, ok := keySet[k]; !ok {
			result[k] = v
		}
	}
	return result
}

// InvertComp inverts the keys and values of a map.
//
// This function takes an input map `m` with keys of type `K` and values of type `V`,
// and creates a new map where the keys and values are swapped. It iterates over each
// key-value pair in the input map and adds an entry to the `result` map with the value
// as the key and the key as the value.
//
// The function is generic, allowing it to work with maps where both the keys and values
// are of any comparable type.
//
// Parameters:
//   - `m`: The input map to be inverted, with keys of type `K` and values of type `V`.
//
// Returns:
//   - A new map of type `map[V]K`, where the keys and values from the input map `m` are swapped.
//
// Example:
//
//	// Inverting a map with string keys and integer values
//	m := map[string]int{"a": 1, "b": 2, "c": 3}
//	inverted := InvertComp(m)
//	// inverted will be map[int]string{1: "a", 2: "b", 3: "c"}
func InvertComp[K, V comparable](m map[K]V) map[V]K {
	result := make(map[V]K, len(m))
	for k, v := range m {
		result[v] = k
	}
	return result
}

// GetOrDefault retrieves the value for a given key from the map.
//
// This function checks if the specified `key` exists in the map `m`. If the key
// is found, it returns the corresponding value. If the key is not found, it returns
// the provided `defaultValue`.
//
// The function is generic, allowing it to work with maps where the keys are of any
// comparable type `K` and the values are of any type `V`.
//
// Parameters:
//   - `m`: The map from which to retrieve the value. It has keys of type `K` and values of type `V`.
//   - `key`: The key to look for in the map. It should be of the same type `K` as the keys in `m`.
//   - `defaultValue`: The value to return if the key is not found in the map.
//
// Returns:
//   - The value associated with the specified `key` if it exists in the map `m`.
//   - The `defaultValue` if the key is not found.
//
// Example:
//
//	// Retrieving a value from a map with a default fallback
//	m := map[string]int{"a": 1, "b": 2, "c": 3}
//	value := GetOrDefault(m, "b", 0)
//	// value will be 2 as "b" exists in the map
func GetOrDefault[K comparable, V any](m map[K]V, key K, defaultValue V) V {
	if v, ok := m[key]; ok {
		return v
	}
	return defaultValue
}

// HasKey checks if a specified key is present within a given map.
//
// This function takes a map with keys of any comparable type `K` and values of
// any type `V`. It checks if the specified `key` exists in the map `m`. If the key
// is found, it returns `true`; otherwise, it returns `false`.
//
// The function is generic and can be used with maps that have keys of any type
// that supports comparison (e.g., int, string). The value type `V` can be any type.
//
// Parameters:
//   - `m`: The map in which to search for the key. The map has keys of type `K`
//     and values of type `V`.
//   - `key`: The key to search for within `m`. It should be of the same type `K` as
//     the keys in `m`.
//
// Returns:
//   - `true` if `key` is found in `m`, `false` otherwise.
//
// Example:
//
//	ages := map[string]int{"Alice": 30, "Bob": 25}
//	isPresent := HasKey(ages, "Alice") // isPresent will be true as "Alice" is a key in the map
//	prices := map[int]float64{1: 9.99, 2: 19.99}
//	isPresent := HasKey(prices, 3) // isPresent will be false as 3 is not a key in the map
func HasKey[K comparable, V any](m map[K]V, key K) bool {
	_, ok := m[key]
	return ok
}

// FlattenMap flattens a nested map into a single-level map with dot-separated keys.
//
// This function takes a nested map `m` where the keys are strings and the values can be
// either primitive values or other nested maps. It recursively traverses the nested structure,
// constructing new keys by concatenating parent keys with child keys using a dot (".") as a separator.
//
// The function returns a new map where all nested keys are flattened into a single level,
// with the keys representing the path to each value in the original nested map.
//
// Parameters:
//   - `m`: The nested map to be flattened. It has string keys and values of type `any`.
//   - `prefix`: A string prefix used to build the keys during recursion. This is typically an empty string
//     when the function is called initially.
//
// Returns:
//   - A new map of type `map[string]any`, where all nested keys from the input map `m` are flattened
//     into a single level with dot-separated keys.
//
// Example:
//
//	nestedMap := map[string]any{
//		"user": map[string]any{
//			"name": "Alice",
//			"address": map[string]any{
//				"city": "Wonderland",
//				"zip":  "12345",
//			},
//		},
//		"age": 30,
//	}
//	flattened := FlattenMap(nestedMap, "")
//	// flattened will be:
//	// map[string]any{
//	//		"user.name": "Alice",
//	//		"user.address.city": "Wonderland",
//	//		"user.address.zip": "12345",
//	//		"age": 30,
//	// }
func FlattenMap(m map[string]any, prefix string) map[string]any {
	result := make(map[string]any)

	for k, v := range m {
		key := k
		if prefix != "" {
			key = prefix + "." + k
		}

		if nested, ok := v.(map[string]any); ok {
			for nk, nv := range FlattenMap(nested, key) {
				result[nk] = nv
			}
		} else {
			result[key] = v
		}
	}

	return result
}

// UnflattenMap converts a flat map with dot-separated keys into a nested map structure.
//
// This function takes a flat map `m` where the keys are strings that may contain dot (".")
// separators, indicating a nested structure. It reconstructs the nested map by splitting
// the keys at each dot and creating nested maps accordingly.
//
// The function returns a new map where the keys are organized into nested maps based
// of the original flat map.
//
// Parameters:
//   - `m`: The flat map to be unflattened. It has string keys and values of type `any`.
//   - `prefix`: A string prefix to be removed from the keys before processing. This is typically
//     an empty string when the function is called initially.
//
// Returns:
//   - A new map of type `map[string]any`, where the keys from the input map `m` are organized
//     into a nested structure based on the dot-separated keys.
//
// Example:
//
//	flatMap := map[string]any{
//		"user.name": "Alice",
//		"user.address.city": "Wonderland",
//		"user.address.zip": "12345",
//		"age": 30,
//	}
//	unflattened := UnflattenMap(flatMap, "")
//	// unflattened will be:
//	// map[string]any{
//	//		"user": map[string]any{
//	//			"name": "Alice",
//	//			"address": map[string]any{
//	//				"city": "Wonderland",
//	//				"zip": "12345",
//	//			},
//	//		},
//	//		"age": 30,
//	// }
func UnflattenMap(m map[string]any, prefix string) map[string]any {
	result := make(map[string]any)

	for k, v := range m {
		k = strings.TrimPrefix(k, prefix)
		parts := strings.Split(k, ".")
		current := result

		for i, part := range parts {
			if i == len(parts)-1 {
				current[part] = v
			} else {
				if _, ok := current[part]; !ok {
					current[part] = make(map[string]any)
				}
				current = current[part].(map[string]any)
			}
		}
	}

	return result
}
